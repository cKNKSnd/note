(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{290:function(o,s,a){"use strict";a.r(s);var e=a(13),l=Object(e.a)({},(function(){var o=this,s=o._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":o.$parent.slotKey}},[s("h1",{attrs:{id:"noclassdeffounderror和classnotfoundexception区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#noclassdeffounderror和classnotfoundexception区别"}},[o._v("#")]),o._v(" NoClassDefFoundError和ClassNotFoundException区别")]),o._v(" "),s("p",[o._v("在类的加载过程中， JVM 或者 ClassLoader 无法找到对应的类时，都可能会引起这两种异常/错误，由于不同的 ClassLoader 会从不同的地方加载类，有时是错误的 CLASSPATH 类路径导致的这类错误，有时是某个库的 jar 包缺失引发这类错误。"),s("code",[o._v("NoClassDefFoundError")]),o._v(" 表示这个类在编译时期存在，但是在运行时却找不到此类，有时静态初始化块也会导致 "),s("code",[o._v("NoClassDefFoundError")]),o._v(" 错误。")]),o._v(" "),s("blockquote",[s("p",[o._v("ClassLoader 是类路径装载器，在Java 中，类路径装载器一共有三种两类，一类是虚拟机自带的 ClassLoader，分为三种")]),o._v(" "),s("ul",[s("li",[o._v("启动类加载器(Bootstrap) ，负责加载 $JAVAHOME/jre/lib/rt.jar")]),o._v(" "),s("li",[o._v("扩展类加载器(Extension)，负责加载 $JAVAHOME/jre/lib/ext/*.jar")]),o._v(" "),s("li",[o._v("应用程序类加载器(AppClassLoader)，加载当前应用的 classpath 的所有类")])])]),o._v(" "),s("blockquote",[s("p",[o._v("第二类是用户自定义类加载器")]),o._v(" "),s("ul",[s("li",[s("code",[o._v("Java.lang.ClassLoader")]),o._v(" 的子类，用户可以定制类的加载方式。")])])]),o._v(" "),s("p",[o._v("另一方面，"),s("code",[o._v("ClassNotFoundException")]),o._v(" 与编译时期无关，当你尝试在运行时使用反射加载类时，"),s("code",[o._v("ClassNotFoundException")]),o._v(" 就会出现。")]),o._v(" "),s("p",[o._v("简而言之，"),s("code",[o._v("ClassNotFoundException")]),o._v(" 和 "),s("code",[o._v("NoClassDefFoundError")]),o._v(" 都是由 CLASSPATH 中缺少类引起的，通常是由于缺少 JAR 文件而引起的，但是如果 JVM 认为应用运行时找不到相应的引用，就会抛出 "),s("code",[o._v("NoClassDefFoundError")]),o._v(" 错误；当你在代码中显示的加载类比如 "),s("code",[o._v("Class.forName()")]),o._v(" 调用时却没有找到相应的类，就会抛出 "),s("code",[o._v("java.lang.ClassNotFoundException")]),o._v("。")]),o._v(" "),s("ul",[s("li",[s("code",[o._v("NoClassDefFoundError")]),o._v(" 是 JVM 引起的错误，是 unchecked，未经检查的。因此不会使用 try-catch 或者 finally 语句块；另外，"),s("code",[o._v("ClassNotFoundException")]),o._v(" 是受检异常，因此需要 try-catch 语句块或者 try-finally 语句块包围，否则会导致编译错误。")]),o._v(" "),s("li",[o._v("调用 "),s("code",[o._v("Class.forName()")]),o._v("、"),s("code",[o._v("ClassLoader.findClass()")]),o._v(" 和 "),s("code",[o._v("ClassLoader.loadClass()")]),o._v(" 等方法时可能会引起 "),s("code",[o._v("java.lang.ClassNotFoundException")])]),o._v(" "),s("li",[s("code",[o._v("NoClassDefFoundError")]),o._v(" 是链接错误，发生在链接阶段，当解析引用找不到对应的类，就会触发；而 "),s("code",[o._v("ClassNotFoundException")]),o._v(" 是发生在运行时的异常。")])])])}),[],!1,null,null,null);s.default=l.exports}}]);